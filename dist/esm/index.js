import{is_object_literal as e,is_object as r}from"mixme";import*as n from"toposort";class t extends Error{code;constructor(e,r,...n){Array.isArray(r)&&(r=r.filter((function(e){return!!e})).join(" ")),super(r=`${e}: ${r}`),Error.captureStackTrace&&Error.captureStackTrace(this,t),this.code=e;for(let e=0;e<n.length;e++){const r=n[e];for(const e in r){if("code"===e)continue;const n=r[e];void 0!==n&&(this[e]=Buffer.isBuffer(n)?n.toString():null===n?n:JSON.parse(JSON.stringify(n)))}}}}var o=function(...e){return new t(...e)};const i=function({args:r=[],chain:t,parent:i,plugins:u=[]}={}){const f=[],c={register:function(n){if("function"!=typeof n&&!e(n))throw o("PLUGINS_REGISTER_INVALID_ARGUMENT",["a plugin must be an object literal or a function returning an object literal","with keys such as `name`, `required` and `hooks`,",`got ${JSON.stringify(n)} instead.`]);n="function"==typeof n?n(...r):n;const i={};for(const e in n.hooks)n.hooks[e]&&(i[e]=a(e,n.hooks[e]));n.require&&!Array.isArray(n.require)&&(n.require=[n.require]);const u={hooks:i,require:(n.require?Array.isArray(n.require)?n.require:[n.require]:[]).map((e=>{if("string"!=typeof e)throw s.PLUGINS_REGISTER_INVALID_REQUIRE({name:n.name,require:e});return e})),name:n.name};return f.push(u),t??this},registered:function(e){for(const r of f)if(r.name===e)return!0;return!(null==i||!i.registered(e))},get:function({name:e,hooks:r=[],sort:t=!0}){const o=[...a(e,r),...f.map((function(r){if(r.hooks[e]){for(const e of r.require)if(!c.registered(e))throw s.REQUIRED_PLUGIN({plugin:r.name,require:e});return r.hooks[e]?.map((e=>({plugin:r.name,require:r.require,...e})))}})).filter((function(e){return void 0!==e})).flat(1),...i?i.get({name:e,sort:!1}):[]];if(!t)return o;const u={};for(const e of o)e.plugin&&(u[e.plugin]=e);const g=[...o.map((function(r){return r.after.reduce((function(n,t){if(u[t])n.push([u[t],r]);else if(c.registered(t))throw s.PLUGINS_HOOK_AFTER_INVALID({name:e,plugin:r.plugin,after:t});return n}),[])})),...o.map((function(r){return r.before.reduce((function(n,t){if(u[t])n.push([r,u[t]]);else if(c.registered(t))throw s.PLUGINS_HOOK_BEFORE_INVALID({name:e,plugin:r.plugin,before:t});return n}),[])}))].flat(1);return n.array(o,g)},call:async function({args:r,handler:n,hooks:t=[],name:i}){if(1!==arguments.length)throw o("PLUGINS_INVALID_ARGUMENTS_NUMBER",["function `call` expect 1 object argument,",`got ${arguments.length} arguments.`]);if(!e(arguments[0]))throw o("PLUGINS_INVALID_ARGUMENT_PROPERTIES",["function `call` expect argument to be a literal object","with the properties `name`, `args`, `hooks` and `handler`,",`got ${JSON.stringify(arguments[0])} arguments.`]);if("string"!=typeof i)throw o("PLUGINS_INVALID_ARGUMENT_NAME",["function `call` requires a property `name` in its first argument,",`got ${JSON.stringify(arguments[0])} argument.`]);const a=this.get({hooks:t,name:i});n=n||(()=>{});for(const e of a)switch(e.handler.length){case 0:case 1:await e.handler(r,(()=>{}));break;case 2:const t=await e.handler(r,n);if(null===t)return null;n=t;break;default:throw o("PLUGINS_INVALID_HOOK_HANDLER",["hook handlers must have 0 to 2 arguments",`got ${e.handler.length}`])}return n?n(r,(()=>{})):void 0},call_sync:function({args:r,handler:n,hooks:t=[],name:i}){if(1!==arguments.length)throw o("PLUGINS_INVALID_ARGUMENTS_NUMBER",["function `call` expect 1 object argument,",`got ${arguments.length} arguments.`]);if(!e(arguments[0]))throw o("PLUGINS_INVALID_ARGUMENT_PROPERTIES",["function `call` expect argument to be a literal object","with the properties `name`, `args`, `hooks` and `handler`,",`got ${JSON.stringify(arguments[0])} arguments.`]);if("string"!=typeof i)throw o("PLUGINS_INVALID_ARGUMENT_NAME",["function `call` requires a property `name` in its first argument,",`got ${JSON.stringify(arguments[0])} argument.`]);const a=this.get({hooks:t,name:i});n=n||(()=>{});for(const e of a)switch(e.handler.length){case 0:case 1:e.handler(r,(()=>{}));break;case 2:const t=e.handler(r,n);if(null===t)return null;n=t;break;default:throw o("PLUGINS_INVALID_HOOK_HANDLER",["hook handlers must have 0 to 2 arguments",`got ${e.handler.length}`])}return n?n(r,(()=>{})):void 0}};for(const e of u)c.register(e);return c},a=function(e,n){return(Array.isArray(n)?n:[n]).map((function(n){if("function"!=typeof n&&!r(n))throw o("PLUGINS_HOOK_INVALID_HANDLER",["no hook handler function could be found,","a hook must be defined as a function","or as an object with an handler property,",`got ${JSON.stringify(n)} instead.`]);return{after:"function"!=typeof n&&n.after?"string"==typeof n.after?[n.after]:n.after:[],name:e,before:"function"!=typeof n&&n.before?"string"==typeof n.before?[n.before]:n.before:[],handler:"function"==typeof n?n:n.handler}}))},s={PLUGINS_HOOK_AFTER_INVALID:function({name:e,plugin:r,after:n}){throw o("PLUGINS_HOOK_AFTER_INVALID",[`the hook ${JSON.stringify(e)}`,r?`in plugin ${JSON.stringify(r)}`:"","references an after dependency",`in plugin ${JSON.stringify(n)} which does not exists.`])},PLUGINS_HOOK_BEFORE_INVALID:function({name:e,plugin:r,before:n}){throw o("PLUGINS_HOOK_BEFORE_INVALID",[`the hook ${JSON.stringify(e)}`,r?`in plugin ${JSON.stringify(r)}`:"","references a before dependency",`in plugin ${JSON.stringify(n)} which does not exists.`])},REQUIRED_PLUGIN:function({plugin:e,require:r}){throw o("REQUIRED_PLUGIN",[`the plugin ${JSON.stringify(e)}`,"requires a plugin",`named ${JSON.stringify(r)} which is not unregistered.`])},PLUGINS_REGISTER_INVALID_REQUIRE:function({name:e,require:r}){throw o("PLUGINS_REGISTER_INVALID_REQUIRE",["the `require` property",e?`in plugin ${JSON.stringify(e)}`:"","must be a string or an array,",`got ${JSON.stringify(r)}.`])}};export{t as PlugableError,i as plugandplay};
//# sourceMappingURL=index.js.map
